import numpy as np
import operator
from LocalModelGp import LocalModel

class LGR(object):

    def __init__(self, opt,dim):
    	self.D = dim
    	self.M = 0  # number of local models
    	self.opt = opt
    	self.beta=opt.beta #noise of data
    	self.lmodels = [None] * opt.max_num_lm
    	for i in range(0, opt.max_num_lm):
    		self.lmodels[i] = LocalModel(opt, self.D)
            
            
    def add_local_model(self, X=None ,Y=None): 
        if(self.M + 1 < self.opt.max_num_lm):
            self.lmodels[self.M].init_lm(X, Y) #CHANGE INIT_LM
            self.M = self.M + 1
        else:
            print("maximum number of local models reached")

        return 0
        
    def initialize_lm(self, X):
        n_data = X.shape[0]

        self.add_local_model(X[0, :])

        for n in range(0, n_data):
            xn = X[n, :]
            w = np.zeros(self.M)
            for m in range(0, self.M):
                lm = self.lmodels[m]
                w[m] = lm.get_ww(xn[np.newaxis, :])
            
            max_act = w.max()
            if max_act < self.opt.activ_thresh:
                self.add_local_model(xn)
        
    def train(self, X, Y):
    		n_data = X.shape[0]
    		w = np.zeros(n_data)
    		for m in range(0, self.M):
    			x=[]
    			y=[]
    			lm = self.lmodels[m]
    			print(m)
    			w= lm.get_ww(X)
    			print(w)
    			
    			for i in np.arange(0,n_data,1):
    				if w[:,i]>10**(-10):
    					x.append(X[i])
    					y.append(Y[i])
    			print(x,y)
    			lm.init_lm(lm.center,x, y)
            
    def predict(self, x): 
    	yp = 0.0
    	sig=10**(-10)
    	wtot=0.0
    	for m in range(0, self.M):
    		lm = self.lmodels[m]
    		w =  self.lmodels[m].get_ww(x) 
    		y_pred, sigma=  self.lmodels[m].predict_(x)
    		sig=1/sig+1/(sigma)
    		wtot+=np.array(w)
    		yp += w * np.array(y_pred).reshape(w.shape)
    	return yp/wtot, 1/sig
    
    def update(self,x_new,y_new):
    	n_data = x_new.shape[0]
    	self.add_local_model( x_new[0, :])
    	for n in range(0, n_data):
    		xn = x_new[n, :]
    		w = np.zeros(self.M)
    		for m in range(0, self.M-1):
    			lm = self.lmodels[m]
    			w[m] = lm.get_ww(xn[np.newaxis, :])
    			index, max_act = max(enumerate(w), key=operator.itemgetter(1))
    		print(index,max_act)
    		if max_act < self.opt.activ_thresh:
    			self.add_local_model(xn)
    		else: 
    			self.lmodels[index].update_(x_new,y_new)
    	return 
